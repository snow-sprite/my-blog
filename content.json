{"meta":{"title":"之欧舟 | Blog","subtitle":"随便写写，记录点滴","description":"之欧舟的个人博客，记录生活，记录点滴。","author":"zhiozhou","url":"https://snow-sprite.github.io"},"pages":[{"title":"❀❀心灵聆听","date":"2019-01-18T10:11:16.000Z","updated":"2019-02-18T10:18:28.551Z","comments":true,"path":"notes/index.html","permalink":"https://snow-sprite.github.io/notes/index.html","excerpt":"","text":"圆圆圈圈圆圆 圈圈圆圆圈圈的我"},{"title":"page","date":"2019-02-18T03:38:23.000Z","updated":"2019-02-18T10:18:28.551Z","comments":true,"path":"notes/note2.html","permalink":"https://snow-sprite.github.io/notes/note2.html","excerpt":"","text":"今天上午心情稍微有点不美丽"}],"posts":[{"title":"1.设计循环队列","slug":"1.Circular queue","date":"2019-11-22T13:38:41.000Z","updated":"2019-11-22T14:54:26.531Z","comments":true,"path":"posts/61605a2e.html","link":"","permalink":"https://snow-sprite.github.io/posts/61605a2e.html","excerpt":"","text":"设计循环队列先简单讲下队列队列就像我们常见的排队一样，先排队的人先离开，后排队的人后离开（排除所有其他干扰因素），插入（insert）操作也被称为入队(enqueue)，新元素始终被添加在队列的末尾，删除(delete)操作也被称为出队(dequeue)，不论正向还是反方向，你只能操作第一个元素 循环队列循环队列是一个线性结构，遵循FIFO（先进先出）原则并且队尾被连接在队首之后形成一个闭合的循环。也被称为“环形缓冲器”。循环队列的好处是可以利用这个队列之前用过的空间，在一个普通队列里，一旦队列满了就不能再往里面插入元素，即使这个队列前面有删除的元素也没法再继续使用，而循环队列则可以高效的利用这部分空间。 设计一个函数MyCircularQueue至少实现以下效果 MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 思路：我们假设需要一个固定长度的数组，然后设置两个变量分别存储队首和队尾索引，如果队列有空闲，新插入的元素自动插入到当前队尾后直到队列满为止。先考虑队列队首元素、队尾元素、空、满状态，操作插入删除操作时，会更有一点前进的方向. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Initialize your data structure here. Set the size of the queue to be k. * @param &#123;number&#125; k * 初始化构造函数 * 当前队列长度为k * 初始队首和队尾都为-1 * 初始队列为空数组 */var MyCircularQueue = function(k) &#123; this.length = k; this.head = -1; this.tail = -1; this.queue = [];&#125;;/** * Insert an element into the circular queue. Return true if the operation is successful. * @param &#123;number&#125; value * @return &#123;boolean&#125; * 首次插入元素时需要将head设置为0，多次插入时 tail每次加1就行 * 这里不能用数组push操作，因为当数组有空间时，队尾还要循环回来衔接队首 * */MyCircularQueue.prototype.enQueue = function(value) &#123; if (this.isFull()) return false if (this.isEmpty()) &#123; this.head = 0 &#125; this.tail++ this.queue[this.tail] = value return true &#125;;/** * Delete an element from the circular queue. Return true if the operation is successful. * @return &#123;boolean&#125; * 首先删除队首 * 删除操作不能有空的时候，不然返回false * 当删除操作删除到最后一位时，再删除数组将为空，将head及tail、queue恢复至默认状态 */MyCircularQueue.prototype.deQueue = function() &#123; if (this.isEmpty()) return false if (this.head == this.queue.length - 1 &amp;&amp; this.tail == this.queue.length - 1) &#123; this.queue = [] this.head = -1 this.tail = -1 return true &#125; this.queue.shift() this.tail-- return true&#125;;/** * Get the front item from the queue. * @return &#123;number&#125; * 返回队首元素 */MyCircularQueue.prototype.Front = function() &#123; if (this.isEmpty()) return -1 return this.queue[this.head]&#125;;/** * Get the last item from the queue. * @return &#123;number&#125; * 返回队尾元素 */MyCircularQueue.prototype.Rear = function() &#123; if (this.isEmpty()) return -1 return this.queue[this.tail]&#125;;/** * Checks whether the circular queue is empty or not. * @return &#123;boolean&#125; * 当head和tail都为-1时候，队列为空 */MyCircularQueue.prototype.isEmpty = function() &#123; if (this.head == -1 &amp;&amp; this.tail == -1) return true return false&#125;;/** * Checks whether the circular queue is full or not. * @return &#123;boolean&#125; * 1. 当head为0并且tail为当前队列长度-1时，队列是满的 * 2. 当tail小于head时，说明队尾已经循环回来了，当head减tail等于1的时候，正好队尾接上队首 */MyCircularQueue.prototype.isFull = function() &#123; if (this.head == 0 &amp;&amp; this.tail == this.length - 1) return true if (this.tail &lt; this.head &amp;&amp; this.head - this.tail == 1) return true return false&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * var obj = new MyCircularQueue(k) * var param_1 = obj.enQueue(value) * var param_2 = obj.deQueue() * var param_3 = obj.Front() * var param_4 = obj.Rear() * var param_5 = obj.isEmpty() * var param_6 = obj.isFull() */","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://snow-sprite.github.io/tags/algorithm/"}],"keywords":[]},{"title":"nvm的安装","slug":"nvm_install","date":"2019-03-04T07:58:55.000Z","updated":"2019-04-03T10:27:06.639Z","comments":true,"path":"posts/b2b0af19.html","link":"","permalink":"https://snow-sprite.github.io/posts/b2b0af19.html","excerpt":"","text":"卸载当前node官网pkg安装包安装的1sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125; homebrew安装的1brew uninstall node tips node卸载完，基于node的软件和命令行工具也需要重新安装，需要删除/usr/local/bin 下面的相关文件，其实他们都是软连接，正主都在/usr/local/lib/node_modules/目录下. 安装nvm安装方式nvm官方文档 安装报错 我在安装过程中可能会报错没有.nvm目录（具体报错信息不记得了 - -!），新建即可12cd ~mkdir .nvm 再次运行安装命令会把安装文件填充到该目录 提示：command not found: nvm复制安装时 提示最底下的三行命令：123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 然后1vim ~/.bash_profile #将复制的文本粘贴进来 如果使用zsh，在.zshrc中也粘进去 如图：如果以上设置仍不生效，尝试：12vim ~/.bash_profilesource .bashrc 使用nvm1234567891011nvm ls ## 查找本电脑上所有的node版本nvm install ## 安装最新版本nvmnvm uninstall &lt;version&gt; ## 卸载制定的版本nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm current ## 显示当前版本nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包nvm on ## 打开nodejs控制nvm off ## 关闭nodejs控制nvm proxy ## 查看设置与代理 好了，愉快的使用nvm来管理node吧 最后，别忘了将之前全局安装的软件重新安装一遍→ →1npm install -g @vue/cli@3.1.3 @vue/cli-init@3.1.1 babel-eslint@9.0.0 bower@1.8.4 chromedriver@2.41.0 create-react-app@1.5.2 eslint@5.10.0 eslint-config-airbnb@17.1.0 eslint-config-react-app@3.0.5 eslint-config-standard@12.0.0 eslint-plugin-flowtype@2.0.1 eslint-plugin-import@2.14.0 eslint-plugin-jsx-a11y@6.1.1 eslint-plugin-node@8.0.0 eslint-plugin-promise@4.0.1 eslint-plugin-react@7.11.1 eslint-plugin-standard@4.0.0 eslint-plugin-vue@5.0.0 express@4.16.4 express-generator@4.16.0 gulp@3.9.1 gulp-cli@2.0.1 hexo-cli@1.1.0 nrm@1.0.2 parcel-bundler@1.9.7 pm2@3.0.4 react-native-cli@2.0.1 sass@1.13.1 typescript@3.1.1 webpack@4.17.2 wepy-cli@1.7.3","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"https://snow-sprite.github.io/tags/tool/"}],"keywords":[]},{"title":"年后第一篇","slug":"🐭","date":"2019-02-19T09:45:53.000Z","updated":"2019-02-20T10:22:21.000Z","comments":true,"path":"posts/6d323993.html","link":"","permalink":"https://snow-sprite.github.io/posts/6d323993.html","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Happy New Year","slug":"Happy New Year","date":"2019-01-18T10:33:05.000Z","updated":"2019-02-18T10:18:28.550Z","comments":true,"path":"posts/2a70ced8.html","link":"","permalink":"https://snow-sprite.github.io/posts/2a70ced8.html","excerpt":"","text":"马上过年了，预祝各位新的一年里芝麻开花，玉兔东升。 ：）","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-10T02:26:22.000Z","updated":"2019-02-18T10:38:37.041Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://snow-sprite.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome!","categories":[],"tags":[],"keywords":[]}]}