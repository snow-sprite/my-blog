{"meta":{"title":"之欧舟 | Blog","subtitle":"随便写写，记录点滴","description":"之欧舟的个人博客，记录生活，记录点滴。","author":"zhiozhou","url":"https://snow-sprite.github.io"},"pages":[{"title":"","date":"2019-12-08T11:22:14.334Z","updated":"2018-08-28T11:02:05.051Z","comments":true,"path":"html/CANVAS跟随鼠标的旋转光圈.html","permalink":"https://snow-sprite.github.io/html/CANVAS跟随鼠标的旋转光圈.html","excerpt":"","text":"var SCREEN_WIDTH = window.innerWidth; var SCREEN_HEIGHT = window.innerHeight; var RADIUS = 70; var RADIUS_SCALE = 1; var RADIUS_SCALE_MIN = 1; var RADIUS_SCALE_MAX = 1.5; var QUANTITY = 25; var canvas; var context; var particles; var mouseX = SCREEN_WIDTH * 0.5; var mouseY = SCREEN_HEIGHT * 0.5; var mouseIsDown = false; function init() { canvas = document.getElementById( 'world' ); if (canvas && canvas.getContext) { context = canvas.getContext('2d'); // Register event listeners window.addEventListener('mousemove', documentMouseMoveHandler, false); window.addEventListener('mousedown', documentMouseDownHandler, false); window.addEventListener('mouseup', documentMouseUpHandler, false); document.addEventListener('touchstart', documentTouchStartHandler, false); document.addEventListener('touchmove', documentTouchMoveHandler, false); window.addEventListener('resize', windowResizeHandler, false); createParticles(); windowResizeHandler(); setInterval( loop, 1000 / 60 ); } } function createParticles() { particles = []; for (var i = 0; i < QUANTITY; i++) { var particle = { size: 1, position: { x: mouseX, y: mouseY }, offset: { x: 0, y: 0 }, shift: { x: mouseX, y: mouseY }, speed: 0.01+Math.random()*0.04, targetSize: 1, fillColor: '#' + (Math.random() * 0x904040 + 0xaaaaaa | 0).toString(16), orbit: RADIUS*.5 + (RADIUS * .5 * Math.random()) }; particles.push( particle ); } } function documentMouseMoveHandler(event) { mouseX = event.clientX - (window.innerWidth - SCREEN_WIDTH) * .5; mouseY = event.clientY - (window.innerHeight - SCREEN_HEIGHT) * .5; } function documentMouseDownHandler(event) { mouseIsDown = true; } function documentMouseUpHandler(event) { mouseIsDown = false; } function documentTouchStartHandler(event) { if(event.touches.length == 1) { event.preventDefault(); mouseX = event.touches[0].pageX - (window.innerWidth - SCREEN_WIDTH) * .5;; mouseY = event.touches[0].pageY - (window.innerHeight - SCREEN_HEIGHT) * .5; } } function documentTouchMoveHandler(event) { if(event.touches.length == 1) { event.preventDefault(); mouseX = event.touches[0].pageX - (window.innerWidth - SCREEN_WIDTH) * .5;; mouseY = event.touches[0].pageY - (window.innerHeight - SCREEN_HEIGHT) * .5; } } function windowResizeHandler() { SCREEN_WIDTH = window.innerWidth; SCREEN_HEIGHT = window.innerHeight; canvas.width = SCREEN_WIDTH; canvas.height = SCREEN_HEIGHT; } function loop() { if( mouseIsDown ) { RADIUS_SCALE += ( RADIUS_SCALE_MAX - RADIUS_SCALE ) * (0.02); } else { RADIUS_SCALE -= ( RADIUS_SCALE - RADIUS_SCALE_MIN ) * (0.02); } RADIUS_SCALE = Math.min( RADIUS_SCALE, RADIUS_SCALE_MAX ); context.fillStyle = 'rgba(0,0,0,0.05)'; context.fillRect(0, 0, context.canvas.width, context.canvas.height); for (i = 0, len = particles.length; i < len; i++) { var particle = particles[i]; var lp = { x: particle.position.x, y: particle.position.y }; // Rotation particle.offset.x += particle.speed; particle.offset.y += particle.speed; // Follow mouse with some lag particle.shift.x += ( mouseX - particle.shift.x) * (particle.speed); particle.shift.y += ( mouseY - particle.shift.y) * (particle.speed); // Apply position particle.position.x = particle.shift.x + Math.cos(i + particle.offset.x) * (particle.orbit*RADIUS_SCALE); particle.position.y = particle.shift.y + Math.sin(i + particle.offset.y) * (particle.orbit*RADIUS_SCALE); // Limit to screen bounds particle.position.x = Math.max( Math.min( particle.position.x, SCREEN_WIDTH ), 0 ); particle.position.y = Math.max( Math.min( particle.position.y, SCREEN_HEIGHT ), 0 ); particle.size += ( particle.targetSize - particle.size ) * 0.01; if( Math.round( particle.size ) == Math.round( particle.targetSize ) ) { particle.targetSize = 1 + Math.random() * 2; } context.beginPath(); context.fillStyle = particle.fillColor; context.strokeStyle = particle.fillColor; context.lineWidth = particle.size; context.moveTo(lp.x, lp.y); context.lineTo(particle.position.x, particle.position.y); context.stroke(); context.arc(particle.position.x, particle.position.y, particle.size/2, 0, Math.PI*2, true); context.fill(); } } window.onload = init;"},{"title":"❀❀心灵聆听","date":"2019-01-18T10:11:16.000Z","updated":"2019-02-18T10:18:28.551Z","comments":true,"path":"notes/index.html","permalink":"https://snow-sprite.github.io/notes/index.html","excerpt":"","text":"圆圆圈圈圆圆 圈圈圆圆圈圈的我"},{"title":"page","date":"2019-02-18T03:38:23.000Z","updated":"2019-02-18T10:18:28.551Z","comments":true,"path":"notes/note2.html","permalink":"https://snow-sprite.github.io/notes/note2.html","excerpt":"","text":"今天上午心情稍微有点不美丽"},{"title":"","date":"2019-12-08T11:22:25.387Z","updated":"2019-12-01T12:04:20.869Z","comments":true,"path":"html/CANVAS炸裂.html","permalink":"https://snow-sprite.github.io/html/CANVAS炸裂.html","excerpt":"","text":"eval(function (p, a, c, k, e, d) { e = function (c) { return (c < a ? \"\" : e(parseInt(c / a))) + ((c = c % a) > 35 ? String.fromCharCode(c + 29) : c.toString(36)) }; if (!''.replace(/^/, String)) { while (c--) d[e(c)] = k[c] || e(c); k = [function (e) { return d[e] }]; e = function () { return '\\\\w+' }; c = 1; }; while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]); return p; }('12 j={7H:{}};j.2k=\"8\"==1v 1M.4X?1M.2k:8(e,r,p){13(p.5z||p.5A){5B 2J 5y(\"5v 5w 5x 5C 5H 5I 5J.\")}e!=1V.1I&&e!=1M.1I&&(e[r]=p.1j)};j.4p=8(e){o\"2L\"!=1v 1r&&1r===e?e:\"2L\"!=1v 1k&&2z!=1k?1k:e};j.1k=j.4p(1x);j.4s=\"5G\";j.3n=8(){j.3n=8(){};j.1k.1s||(j.1k.1s=j.1s)};j.4r=0;j.1s=8(e){o j.4s+(e||\"\")+j.4r++};j.2A=8(){j.3n();12 e=j.1k.1s.1O;e||(e=j.1k.1s.1O=j.1k.1s(\"1O\"));\"8\"!=1v 1V.1I[e]&&j.2k(1V.1I,e,{4e:!0,48:!0,1j:8(){o j.41(1x)}});j.2A=8(){}};j.41=8(e){12 r=0;o j.3X(8(){o r"},{"title":"","date":"2019-12-08T11:22:30.375Z","updated":"2019-12-01T04:01:11.854Z","comments":true,"path":"html/CANVAS时钟.html","permalink":"https://snow-sprite.github.io/html/CANVAS时钟.html","excerpt":"","text":"No canvas, no particles var Clock = (function () { // private variables var canvas, // canvas element ctx, // canvas context bgGrad = true, // background gradient flag gradient, // gradient (background) height = 400, // canvas height key = { up: false, shift: false }, // key presses particles = [], // particle array particleColor = 'hsla(0, 0%, 100%, 0.3)', // particle color mouse = { x: 0, y: 0 }, // position of mouse / touch press = false, // pressed flag quiver = false, // quiver flag text, // the text to copy pixels from textSize = 140, // (initial) textsize valentine = false, // valentine-ify it for a bit? msgTime = 100, // time to show a message before returning to clock updateColor = true, // update color of gradient / particles with time? width = 800; // canvas width // Constants var FRAME_RATE = 20, // frames per second target MIN_WIDTH = 800, // minimum width of canvas MIN_HEIGHT = 400, // minimum height of canvas PARTICLE_NUM = 600, // (max) number of particles to generate RADIUS = Math.PI * 2; // radius of particle var defaultStyles = function () { textSize = 140; // particle color particleColor = 'hsla(0, 0%, 100%, 0.3)'; // color stops var gradientStops = { 0: '#333333', 0.5: '#222222' }; // create gradient setGradient(gradientStops); }; var draw = function (p) { ctx.fillStyle = particleColor; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, RADIUS, true); ctx.closePath(); ctx.fill(); }; var explode = function () { for (var i = 0, l = particles.length; i < l; i++) { var p = particles[i]; if (p.inText) { var ax = mouse.x - p.px, ay = mouse.y - p.py, angle = Math.atan2(ay, ax), polarity, C = Math.cos(angle), S = Math.sin(angle); // change polarity // attract particles if mouse pressed, repel if shift + mousedown polarity = (key.shift === true) ? -1 : 1; p.x += polarity * (Math.pow((C - 1), 2) - 1) + p.velocityX * p.delta; p.y += polarity * (Math.pow((S - 1), 2) - 1) + p.velocityY * p.delta; // set previous positions p.px = p.x; p.py = p.y; draw(p); } } }; var getTime = function (amPM) { var date = new Date(), hours = date.getHours(), timeOfDay = ''; // if (amPM) { // // hours = (hours > 12) ? hours -= 12 : hours; // hours = (hours == 12) ? 0 : hours; // } else { // hours = (hours == 12) ? 12 : hours; // hours = hours // } var minutes = pad(date.getMinutes()); var seconds = pad(date.getSeconds()); return { hours: hours, minutes: minutes, seconds: seconds, timeString: hours + \" : \" + minutes + \" : \" + seconds }; }; // animation loop var loop = function () { // clear out text ctx.clearRect(0, 0, width, height); var hours = new Date().getHours() var bool = (hours 0) { textSize = 180; text = '?'; msgTime--; } else { text = time.timeString; } // valentine-ify it by setting hue to pink setStyles(300); } else if (updateColor === true && bgGrad === true) { // changing color with time // @TODO: come up with something better, this is a hacky implementation var color = time.hours + time.minutes + time.seconds; setStyles(color); text = time.timeString; } else { defaultStyles(); text = time.timeString; } ctx.fillStyle = \"rgb(255, 255, 255)\"; ctx.textBaseline = \"middle\"; ctx.font = textSize + \"px 'Avenir', 'Helvetica Neue', 'Arial', 'sans-serif'\"; ctx.fillText(text, (width - ctx.measureText(text).width) * 0.5, height * 0.5); // copy pixels var imgData = ctx.getImageData(0, 0, width, height); // clear canvas, again ctx.clearRect(0, 0, width, height); if (bgGrad === true) { // draw gradient ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height); } if (press === false) { // reset particles for (var i = 0, l = particles.length; i < l; i++) { var p = particles[i]; p.inText = false; } particleText(imgData); } else { explode(); } FPS.update('fps'); }; var pad = function (number) { return ('0' + number).substr(-2); }; var particleText = function (imgData) { var pxls = []; for (var w = width; w > 0; w -= 6) { for (var h = 0; h < width; h += 6) { var index = (w + h * (width)) * 4; if (imgData.data[index] > 10) { pxls.push([w, h]); } } } var count = pxls.length; for (var i = 0; i < pxls.length && i < particles.length; i++) { try { var p = particles[i], X, Y; if (quiver) { X = (pxls[count - 1][0]) - (p.px + Math.random() * 5); Y = (pxls[count - 1][1]) - (p.py + Math.random() * 5); } else { X = (pxls[count - 1][0]) - p.px; Y = (pxls[count - 1][1]) - p.py; } // tangent var T = Math.sqrt(X * X + Y * Y); // arctangent var A = Math.atan2(Y, X); // cosine var C = Math.cos(A); // sine var S = Math.sin(A); // set new postition p.x = p.px + C * T * p.delta; p.y = p.py + S * T * p.delta; // set previous positions p.px = p.x; p.py = p.y; p.inText = true; // draw the particle draw(p); if (key.up === true) { p.size += 0.3; } else { var newSize = p.size - 0.5; if (newSize > p.origSize && newSize > 0) { p.size = newSize; } else { p.size = m.origSize; } } } catch (e) { //console.log(e); } count--; } }; var setCoordinates = function (e) { if (e.offsetX) { return { x: e.offsetX, y: e.offsetY }; // use offset if available } else if (e.layerX) { return { x: e.layerX, y: e.layerY }; // firefox... make sure to position the canvas } else { // iOS. Maybe others too? return { x: e.pageX - canvas.offsetLeft, y: e.pageY - canvas.offsetTop }; } }; // set dimensions of canvas var setDimensions = function () { width = Math.max(window.innerWidth, MIN_WIDTH); height = Math.max(window.innerHeight, MIN_HEIGHT); // Resize the canvas canvas.width = width; canvas.height = height; canvas.style.position = 'absolute'; canvas.style.left = '0px'; canvas.style.top = '0px'; }; var setGradient = function (gradientStops) { // create gradient gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width); // iterate through colorstops for (var position in gradientStops) { var color = gradientStops[position]; gradient.addColorStop(position, color); } }; var setStyles = function (hue) { // color stops var gradientStops = { 0: 'hsl(' + hue + ', 100%, 100%)', 0.5: 'hsl(' + hue + ', 10%, 50%)' }; // change particle color particleColor = 'hsla(' + hue + ', 10%, 50%, 0.3)'; // create gradient setGradient(gradientStops); }; /** * Public Methods */ return { init: function (canvasID) { canvas = document.getElementById(canvasID); // make sure canvas exists and that the browser understands it if (canvas === null || !canvas.getContext) { return; } // set context ctx = canvas.getContext(\"2d\"); // set dimensions setDimensions(); // ui this.ui(); for (var i = 0; i < PARTICLE_NUM; i++) { particles[i] = new Particle(canvas); } // show FPS FPS.initialize(canvas, 'fps'); // set defaults defaultStyles(); // let's do this setInterval(loop, FRAME_RATE); }, ui: function () { // UI: buttons and events document.addEventListener('keydown', function (e) { switch (e.keyCode) { case 16: // shift key.shift = true; e.preventDefault(); break; case 38: // up key key.up = true; e.preventDefault(); break; } }, false); document.addEventListener('keyup', function (e) { switch (e.keyCode) { case 16: // shift key.shift = false; e.preventDefault(); break; case 38: // space key.up = false; e.preventDefault(); break; } }, false); window.addEventListener('resize', function (e) { setDimensions(); }, false); canvas.addEventListener('mousedown', function (e) { press = true; }, false); document.addEventListener('mouseup', function (e) { press = false; }, false); canvas.addEventListener('mousemove', function (e) { if (press) { mouse = setCoordinates(e); } }, false); // @TODO: add touch events } }; })(); // Create new particles var Particle = function (canvas) { var range = Math.random() * 180 / Math.PI, // random starting point spread = canvas.height, // how far away from text should the particles begin? size = Math.random() * 7; // random size of particle this.delta = 0.25; this.x = 0; this.y = 0; // starting positions this.px = (canvas.width / 2) + (Math.cos(range) * spread); this.py = (canvas.height / 2) + (Math.sin(range) * spread); this.velocityX = Math.floor(Math.random() * 10) - 5; this.velocityY = Math.floor(Math.random() * 10) - 5; this.size = size; this.origSize = size; this.inText = false; }; var FPS = { // defaults delta: 0, lastTime: 0, frames: 0, totalTime: 0, updateTime: 0, updateFrames: 0, initialize: function (canvasID, fpsID) { this.lastTime = (new Date()).getTime(); if (!document.getElementById(fpsID) && document.getElementById(canvasID)) { this.createFPS(canvasID, fpsID); } }, // create FPS div if needed createFPS: function (canvasID, fpsID) { var div = document.createElement('div'); div.setAttribute('id', fpsID); var canvas = document.getElementById(canvasID); var parent = canvas.parentNode; div.innerHTML = \"FPS AVG: 0 CURRENT: 0\"; parent.appendChild(div); }, // update FPS count update: function (fpsID) { var now = (new Date()).getTime(); this.delta = now - this.lastTime; this.lastTime = now; this.updateTime += this.delta; this.totalTime += this.delta; this.frames++; this.updateFrames++; this.updateTime = 0; // reset time this.updateFrames = 0; // reset frames } }; Clock.init('canvas');"}],"posts":[{"title":"Flutter环境搭建","slug":"Flutter(1)","date":"2020-02-19T09:54:13.000Z","updated":"2020-02-19T10:06:05.629Z","comments":true,"path":"posts/791d854e.html","link":"","permalink":"https://snow-sprite.github.io/posts/791d854e.html","excerpt":"","text":"flutter flutter makes it easy and fast to build beautiful mobile apps. 使用flutter或者react native的主要原因，一般都会是UI一端通用，开发快。就目前而言flutter没有react native生态丰富，毕竟react native开源时间早，积累了一部分用户。但是由于fb的开源协议使得国内一些中大型公司不得不放弃react native，当然还有其他原因比如应用没有原生流畅、后期维护成本高等等。。。 2018年2月世界移动大会上谷歌开源了第一个Fullter Beat版本。现在已经吸引了越来越多的开发者，生态也慢慢的建立起来了。相对于react native，flutter拥有更接近于原生的ui样式，并且包含的许多核心Widget如：导航、图标、字体等，可以在Android和iOS上达到跟原生一样的体验。 特点 热重载（Hot Reload） 这个优点简直无敌了，在最多几秒的时间内更新新的ui、功能、修复bug等，之前开发过iOS应用，每更新一个新功能就得重启一次应用，简直慢的要死。。。 富有表现力，漂亮的用户界面 flutter内置美丽的Material Design和Cupertino(iOS风格) widget，丰富的motionApi、平滑而自然的滑动效果和平台感知。 使用Dart开发语言 一切皆Widget的理念 借助可移植的GPU加速渲染引擎以及高性能本地代码可以达到跨平台设备的高质量用户体验。 安装 由于网络问题，flutter官方为中国开发者搭建了临时镜像，将其加入到环境变量： 12export PUB_HOSTED_URL=https://pub.`flutter`-io.cnexport `flutter`_STORAGE_BASE_URL=https://storage.`flutter`-io.cn 获取flutter SDK 下载地址：https://`flutter`.io/sdk-archive/#macos 运行./flutter/bin/flutter --version 运行flutter upgrade更新版本 临时添加flutter相关工具到path中： 1export PATH=`pwd`/flutter/bin:$PATH 永久添加flutter相关工具到path中： 打开$HOME/.bash_profile 添加以下命令，[PATH_TO_FLUTTER_GIT_DIRECTORY]为flutter repo clone地址 123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 运行source $HOME/.bash_profile刷新当前终端端口。 运行flutter/bin验证目录是否已经在PATH中 1echo $PATH 运行flutter doctor安装其他必须依赖 iOS设置 安装Xcode7.2及以上 测试ios模拟器，建议使用iPhone5及以上 1open -a Simulator 配置编辑器 … 应用初体验 直观感受热更新确实比react native做的更平滑更流畅。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"小酌React-hooks(2)","slug":"React-hooks(2)","date":"2020-02-18T10:18:34.000Z","updated":"2020-02-19T10:05:58.020Z","comments":true,"path":"posts/7b792714.html","link":"","permalink":"https://snow-sprite.github.io/posts/7b792714.html","excerpt":"","text":"1. useLayoutEffectuseLayoutEffct与useEffect使用方式一致，都可以执行副作用和清理操作。唯一的不同是执行时机。useEffect不回阻塞浏览的绘制任务，页面更新后执行。useLayoutEffect跟componentDidMount和componentDidUpdate类似，会阻塞浏览器的绘制任务，如果任务执行时间过长，会造成页面空白。 使用场景： 根据ui执行DOM操作，绝大多数情况下使用useEffect是一个更好的选择。useLayoutEffect会在页面渲染前执行，保证渲染出来的是最终效果。如果使用了useEffect很可能会因为渲染了2次而出现抖动。 2. useContext1const value = useContext(myContext) 接收一个context对象（React.createContext返回值），并返回该context当前值。当前context的值由上层组件距离当前组件最近的&lt;MyContext.Provider&gt;的value、prop决定。当上层&lt;MyContext.provider&gt;更新时，该Hook会触发重新渲染，并将使用最新传递给MyContext的Provider的contextvalue值。 useContext的参数必须是context对象本身： 正确： useContext(MyContext) 错误： useContext(MyContext.Consumer) 错误： useContext(MyContext.Provider) useContext(MyContext)相当于class组件中的static contextType = MyContext或者&lt;MyContext.Consumer&gt; 调用了useContext的组件总会在context的值发生变化时重新渲染。 3. useReduceruseReducer用法跟Redux非常相似。当state的计算逻辑比较复杂或者需要根据以前的值计算新的值时，使用这个Hook会比useState更好。 12345678910111213141516171819202122232425262728293031function init(initialCount) &#123; return &#123;count: initialCount&#125;;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case 'increment': return &#123;count: state.count + 1&#125;; case 'decrement': return &#123;count: state.count - 1&#125;; case 'reset': return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123;initialCount&#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'reset', payload: initialCount&#125;)&#125;&gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'increment'&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 4. useCallback / useMemo / React.memouseCallback和useMemo的设计初衷时用来做性能优化的。 传统onClick方法，每次重新渲染都会重新绑定事件，解决方式是使用bind或者箭头函数。同样函数组件也有这个问题，React给出的方案是useCallback Hook。它会返回相同的引用，避免子组件进行无意义的重复渲染。 useCallback缓存的是方法的引用， 12345678function Foo() &#123; const [count, setCount] = useState(0); const memoizedHandleClick = useCallback( () =&gt; console.log(`Click happened with dependency: $&#123;count&#125;`), [count], ); return &lt;Button onClick=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/Button&gt;;&#125; 而useMemo缓存的则是方法的返回值。 123456789101112function Parent(&#123; a, b &#125;) &#123; // 当 a 改变时才会重新渲染 const child1 = useMemo(() =&gt; &lt;Child1 a=&#123;a&#125; /&gt;, [a]); // 当 b 改变时才会重新渲染 const child2 = useMemo(() =&gt; &lt;Child2 b=&#123;b&#125; /&gt;, [b]); return ( &lt;&gt; &#123;child1&#125; &#123;child2&#125; &lt;/&gt; )&#125; 如果想实现class Component的shouldComponentUpdate方法，可以使用React.memo方法，区别是它只能比较props不能比较state。 useRef Class Component获取ref的方式如下： 1234567891011121314class MyComponent extends React.Component &#123; constrctor(props) &#123; super(props) this.myRef = React.createRef() &#125; componentDidMount() &#123; this.myRef.current.focus() &#125; render() &#123; return ( &lt;input ref=&#123;this.myRef&#125; type=\"text\" /&gt; ) &#125;&#125; Hook实现方式: 12345678function MyComponent() &#123; const myRef = useRef(null) useEffect(() =&gt; &#123; myRef.current.focus() &#125;, []) return &lt;input ref=&#123;myRef&#125; type=\"text\" /&gt;&#125; useRef返回一个普通的js对象，可以将任意类型数据存放到current属性里面，就像使用实例化this一样。另外一个使用场景是获取previous props或previous state: 1234567891011function Counter() &#123; const [count, setCount] = useState(0) const previousRef = useRef() useEffect(() =&gt; &#123; previousRef.current = count &#125;) const previousCount = previousRef.current return &lt;h1&gt; Now: &#123; count &#125;, Before: &#123; previousCount &#125; &lt;/h1&gt;&#125; 6. 自定义hooks自定义Hook可以解决复用组件内带逻辑的部分。 自定义Hook是一个函数，是以use开头的，函数内部可以调用其他Hook。 自定义Hook返回在线状态(true or false) 12345678910111213141516function useFriendStatus(friendId) &#123; const [isOnline, setIsOnline] = useState(null) useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline) &#125; ChatAPI.subscribeToFriendStatus(friendId, handleStatusChange) return () =&gt; &#123; chatAPI.unsubscrbeToFriendStatus(friendId, handleStatusChange) &#125; &#125;) return isOnline&#125; 使用该自定义Hook 根据在线状态显示在线 离线 12345function friendStatus(props) &#123; const isOnline = useFreindStatus(props.friend.id) return isOnline ? 'online' : 'offline'&#125; 显示具体friend信息 123456789function friendInfo(props) &#123; const isOnline = useFriendStatus(props.friend.id) return ( &lt;li style=&#123;isOnline ? 'green' : 'gray'&#125;&gt; &#123; props.friend.name &#125; &lt;/li&gt; )&#125; 7.hooks概览 基础 Hook useState useEffect useContext 额外的 Hook useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"小酌React-hooks","slug":"React-hooks","date":"2020-02-17T09:55:54.000Z","updated":"2020-02-19T10:06:18.131Z","comments":true,"path":"posts/4aba2710.html","link":"","permalink":"https://snow-sprite.github.io/posts/4aba2710.html","excerpt":"","text":"React hooks1. 什么是hooks A way to use state and other React features without writing a class. React Hooks是React从v16.8引入的一种新的更简单更方便的编写组件的功能。hooks提供了一种可以不用写class而直接使用state和其他React特性的能力，而且自定义hooks可以将公共逻辑抽离，使之可以在多个组件之间共享。 2. hooks的由来hooks主要是为了解决以下3个React问题 组件带状态变得难以复用 复杂逻辑不用跟随生命周期 解决难以理解的class js中的this取值跟其他面向对象语言都不同，是在运行时决定的。为了解决这一痛点，才有了箭头函数的this绑定特性。另外何时使用class component 和 function component也是一件容易纠结的事，对于优化方面来说，class component在预编译和压缩方面也比普通函数困难得多，还容易出错。 3. 使用 state hook 1234567891011import &#123; useState &#125; from 'react'function Demo() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;count: &#123; count &#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1) &#125;&#125;&gt;点击&lt;/button&gt; &lt;/div&gt; )&#125; useState只有一个参数，即count的初始值，可以是任意类型。如果count是对象，useState不会像setState自动合并原state，可以： 1234setState(preV =&gt; &#123; return &#123; ...preV, ...updateV &#125; // Object.assign(preV, updateV) &#125;) 多个state变量只需要多次调用useState即可 123456...function Demo2() &#123; const [count, setCount] = useState(0) const [fruit, setFruit] = useState('apple') ...&#125; Effect hook 我们希望组件在DOM挂载和更新后执行相同的操作，使用React Effect hooks写法： 123456789import React, &#123; useEffect &#125; from 'react'function Demo3() &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; document.title = `clicked $&#123;count&#125; times` &#125;)&#125; 传统class component写法： 123456789101112131415161718import React from 'react'class Demo3 extends React.Component&#123; constrctor(props) &#123; super(props) this.state = &#123; count: 0 &#125; &#125; componentDidMount () &#123; document.title = `clicked $&#123;this.state.count&#125; times` &#125; compoenntDidUpdate () &#123; document.title = `clicked $&#123;this.state.count&#125; times` &#125; ...&#125; 传统class component，我们需要在两个生命周期中调用相同的函数，使用Effect特性React会保存传递的函数，并在DOM渲染后调用该函数。useEffect同时拥有componentDidMount,componentDidUpdate,componentWillUnmount三个生命周期的执行时机。但Effct并不会阻塞浏览的渲染，使应用看起来更加流畅。 有时候我们为了防止内存泄漏需要清除的Effct，class component中需要在componentDIdMount中注册并在componentWillUnmount中销毁，使用hooks只需要在useEffct中返回一个函数即可 12345678910function Demo4() &#123; useEffct(() =&gt; &#123; let timer = setInterval(() =&gt; &#123; console.log(1) &#125;) return () =&gt; &#123; clearInterval(timer) &#125; &#125;)&#125; 当useEffct返回一个函数的时候，React会在下一次执行副作用之前调用一次清理函数。 组件挂载 —&gt; 执行副作用 —&gt;组件更新 —&gt;执行清理函数—&gt;执行副作用—&gt;组件更新—&gt;执行清理函数—&gt;组件卸载 所以每次state更新我们都会重新渲染一次，如果state值没有改变的情况下（原来count是5改变后还是5），我们不想调用Effct，只需要在useEffct函数中传入第二个参数[count]即可。React会对前一次渲染的[5]和后一次渲染的[5]对比，数组内元素全部相等，React就会跳过这个Effct，同时实现了性能的优化。该参数为数组，可以传多个数组，一般会将Effct用到的props和state都传进去。清除函数同理。 如果useEffct传入的第二个参数是一个[]，等效于componentDidMount和componentWillUnmount 4. hooks规则 只能在React 函数式组件中调用Hook 只能在函数最外层调用Hook 只能用在函数最顶层 不能用在循环、条件判断语句，嵌套函数 ESLint插件eslint-plugin-react-hooks格式规范 …","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"Redux-Saga","slug":"Redux-Saga","date":"2020-02-14T09:56:56.000Z","updated":"2020-02-19T10:08:31.856Z","comments":true,"path":"posts/fcea62c9.html","link":"","permalink":"https://snow-sprite.github.io/posts/fcea62c9.html","excerpt":"","text":"Redux-SagaRedux-saga是一个用于管理应用程序Side Effect（副作用， 例如异步获取数据，访问浏览器缓存等）库，目标是让副作用管理更容易，执行更高效，测试更简单，处理故障时更容易。 在reduxs-saga中，sages都是由Generator实现的，从Generator中yield一个纯javascript对象以表达那些Saga逻辑。我们称呼那些对象为Effect。 一个saga就像一个单独的线程，独自负责处理副作用。redux-saga是一个redux中间件，意味着这个线程可以通过正常的redux action从主程序启动，暂停，取消，它能访问完整的redux state，以及dispatch redux action。 Redux-saga使用了ES6的Generator功能，让异步的流程更加易于读取，写入和测试。 简单使用： 12345678class Demo extends React.Component&#123; ... onSomeButtonClicked() &#123; const &#123; userId, dispatch &#125; = this.props dispatch(&#123; type: 'USER_FETCH_REQUESTED'， payload: &#123; userId &#125; &#125;) &#125; ...&#125; sagas.js 1234567891011import &#123; call, put, takeEvery &#125; from 'redux-saga/effects'// 获取用户数据function* fetchUser(action) &#123; ...&#125;function* mySaga() &#123; // 允许事件并发，触发获取用户数据事件 yield takeEvery('USER_FETCH_REQUESTED', fetchUser)&#125;export default mySaga main.js 123456789101112131415import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import createSagaMiddleware from 'redux-saga'import reducer from '...'import mySaga from './sagas'const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || composeconst sagaMiddleware = createSagaMiddleware()const store = createStore( reducer, composeEnhancers( applyMiddleware(sagaMiddleware) ))sagaMiddleware.run(mySaga) 常用Effect创建器 take put call apply cancel join getContext … 常见saga辅助函数 takeEvery takeLatest 学习连接 https://redux-saga.js.org","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"Redux","slug":"Redux","date":"2020-02-13T09:33:49.000Z","updated":"2020-02-19T10:08:16.757Z","comments":true,"path":"posts/cb417bc6.html","link":"","permalink":"https://snow-sprite.github.io/posts/cb417bc6.html","excerpt":"","text":"Redux周宁 zhouning@Cid 1. 什么是redux redux是javascript状态容器，由flux发展而来，提供可预测化的状态管理。 2. 什么时候用​ 小型项目只使用react完全够用，数据管理使用props，state即可。但随着业务复杂度的增加，单纯使用react显得有点捉襟见肘，比如一个组件A嵌套多层组件，当传递到子组件E时，纯靠props传递显得有点不爽，中间BCD组件可能并不需要props数据，但迫于无奈仍需要传递。或者是兄弟组件之间想要共享某些数据，也不是很方便。诸如此类的情况，就有必要引入redux了。 3. 好处 3. redux三大原则 单一数据源 整个应用的state被存储在一棵object tree中，并且这个object tree只存在于唯一一个store中。 State只读 唯一改变state的方法就是触发action，action是一个用于描述已发生事件的对象。 改变数据只能通过纯函数实现 action改变state，需要reducers，Reducer只是一些纯函数，它接受先前的state和action，并返回新的state。 4. 核心api Action 一般改变store状态数据会通过store.dispatch()将action传到store，Action内部必须使用一个字符串类型type来表示将要执行的动作，多数情况下type会被定义为字符串常量，当应用规模越来越大，可以使用单独的模块或文件存放action。 1import &#123; ADD, UPDATE &#125; from '../actionTypes' reducer reducer是一个纯函数，根据previousState和action计算出新的state，指定应用状态的改变如何响应action并发送到store 1reducer(previousState, action) store Redux的核心，由Redux提供的createStore(reducer, defaultState)方法生成，并生成三个方法，getState(),dispatch(),subscrible() 三者之间的关系 React-redux connect connect连接React和Redux store，返回一个已与Redux store连接的新组件 12345678910import &#123; connect &#125; from 'react-redux'import &#123; add &#125; from './store/actions/cart-actions'class App extends React.Component&#123; constrctor(props) &#123; super(props) this.state = &#123;&#125; &#125; ...&#125;export default connet(add)(App) Provider 使用React的context可以实现跨组件之间的传递原理，实现store的全局访问，将store传给每个组件。 1234567891011import ReactDOM from 'react-dom'import &#123; Provider &#125; from 'react-redux'import store from './store'import App from './App'ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector('app')) Redux &amp; React-redux","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"React-diff","slug":"React-diff","date":"2020-02-12T08:30:42.000Z","updated":"2020-02-19T10:07:59.123Z","comments":true,"path":"posts/23563060.html","link":"","permalink":"https://snow-sprite.github.io/posts/23563060.html","excerpt":"","text":"React-diffReact是根据Virtual DOM的对比来更新DOM的。这种用来对比的方法被称为diff算法，该算法由fb进一步的优化，使得React的渲染性能得到进一步提升。 1. 传统diff传统diff算法通过循环递归对节点进行依次对比，效率低下，使得算法复杂度为O(n^3)，如果节点数过于庞大，即使cpu的计算速度达到30亿次/s，也很难在1s内计算出结果。 ​ 1）Tree edit distance（树的编辑距离） 从左图修改成右图 删除ul节点 添加p节点 添加text 在递归过程中依次将当前节点拆分成子树，然后依次计算每个子树的edit distance，所以上图的树的最小编辑距离为3 ​ 2）Tree edit distance算法演进 2. React的diffdiff算法的复杂度取决于策略，React采用的三大策略将diff复杂度由O(n^3)转化为O(n)，效果提升如图： 三大策略分别为： tree diff React对树的算法进行了简洁的优化，由于DOM节点操作涉及到跨层级的移动操作少到可以忽略不计，所以React只对树进行分层比较。当发现节点已经不存在时，会删除该节点及所有子节点，不回再做多余的遍历比较，只需要对树进行依次比较即可。 如果涉及到了DOM的跨层级操作，React只会执行添加和删除2个操作，先添加一个新节点，然后添加子节点，再删除旧节点。如下图，执行步骤为： create A =&gt; create B =&gt; create C =&gt; delete A A节点会被重新创建而不是移动，所以React官方建议不要进行DOM节点的跨层级操作，可以通过css属性的隐藏、显示对节点操作，而不是真正的删除、插入节点。 component diff React是基于组件构建应用的，对组件的diff也非常简洁 同一类型组件，按照原策略进行Visual DOM对比 同一类型组件，Visual DOM没发生任何变化，React提供一个shouldComponentUpdate api供用户手动选择是否需要进行diff比较，如果使用了forceUpdate则强制比较，shouldComponentUpdate失效。 不同类型组件，将原有组件标记为dirty component，删除旧组件重新添加新组件。 element diff 当节点处于同一层时，diff提供了3种节点操作 INSERT_MARKUP 组件C不在集合（AB）中，需要插入操作 REMOVE_NODE 组件C在集合（ABC）中，集合需要变成新集合（AB），则需要删除C 组件C在集合（ABC）中，但C改变了，不能复用和移动，需要删除C在新建C MOVE_EXISTING 组件C在集合（ABC）中，集合更新时需要将C和A的位置调换，传统diff需要将C移动到A的位置，并将C和旧A进行diff，再添加C，React diff只需要将C移动到A位置，并添加一个唯一的key进行区分，直接移动即可。 总结 React diff对传统diff进行优化，使得算法复杂度成几何倍减小 尽量减少对DOM跨层级的操作，尤其是将列表最后一项移动到列首 对于同一层级的一组子节点，通过设置唯一key来进行区分 开发组件时，保持稳定的DOM结构有助于性能的提升 懂得借助react diff去解决实际开发中的一系列问题 参考https://www.jianshu.com/p/3ba0822018cf https://www.jianshu.com/p/8e5aee42be35 https://segmentfault.com/a/1190000018914249#item-4-5 https://www.zhihu.com/question/66851503","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"React-Vnode","slug":"React-Vnode","date":"2020-02-11T09:03:32.000Z","updated":"2020-02-19T10:06:26.114Z","comments":true,"path":"posts/d99ac760.html","link":"","permalink":"https://snow-sprite.github.io/posts/d99ac760.html","excerpt":"","text":"React-Vnode1. 为什么用？react渲染和操作真实DOM开销非常大，有时候我们操作某个数据的变化，就会引起整个DOM层的重绘和重排，非常消耗性能。这时千呼万唤，Vnode就可以解决这个痛点。 2. 什么是VnodeVnode其实是一个用于表示真实DOM结构和属性的js对象，这个对象用于对比虚拟DOM和当前真实DOM的差异化，然后从局部渲染从而达到优化性能的目的。比如用js描述一个人： 1&#123; name: 'Jack', age: 20, sex: 'male', children: null &#125; 3. 优点 肯定是性能优化 减少了DOM操作，不论页面有任何变化，都是Vnode和真实DOM对比之后，只需要在最后挂载阶段重新render即可，不需要重复渲染。 兼容性强，不受执行环境的影响。 因为是js对象，所以在浏览器和node端都可以执行，从而获得了服务端渲染，原生渲染，手写函数渲染的能力。 4. 如何用123&lt;div&gt; &lt;p className=\"text\"&gt;text&lt;/p&gt; &lt;/div&gt; 1234567// 经过babel编译，将他们传递给h函数调用h( 'div', null, h('p', &#123;className: 'text'&#125;, 'text'))// react中的React.createElement函数作用跟h函数作用基本一样，结果是为了获取vnode Vdom的两个核心api h函数 h是指hyperscript，一种可以通过js来创建html的库，输出一个dom节点的js对象，类似： 123456&#123; \"nodeName\": \"div\", \"attributes\": &#123;&#125;, \"children\": [...], \"key\": \"id\"&#125; h函数结束后，就开始调用render函数了。 path函数 render阶段，首次渲染调用path(container, vnode)，更新渲染的时候调用path(vnode, newVnode)，通过diff算法，修改真实dom。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"React","slug":"React","date":"2020-02-10T10:02:52.000Z","updated":"2020-02-19T10:10:00.235Z","comments":true,"path":"posts/d8a440d1.html","link":"","permalink":"https://snow-sprite.github.io/posts/d8a440d1.html","excerpt":"","text":"React基础 周宁 zhouning@Cid React是由facebook开源的一款前端库，适用于中大型前端项目 jsxjavascript语法扩展，更好的处理渲染逻辑与ui逻辑内在耦合。 123const element = ( &lt;h1&gt;hello, world!&lt;/h1&gt;) 在编译阶段，Babel会将当前项目所有jsx转译为React.createElement()函数调用，返回当前组件内元素及其属性等。 元素渲染React使用单{}渲染数据。 123456789101112131415import React from 'react'class Demo extends React.Component&#123; constrctor(props) &#123; super(props) this.state = &#123; text: 'hello, world!' &#125; &#125; render() &#123; const &#123; text &#125; = this.state return ( &lt;h1&gt;&#123; text &#125;&lt;/h1&gt; ) &#125;&#125; 使用React构建的应用通常有且仅有一个根结点，只需要将所有的元素传入到ReactDOM.render()即可。 1ReactDOM.render(element, document.querySelector('app')) 组件 &amp;&amp; props 组件允许你将ui拆分为独立可复用的代码片段，并对每个片段进行独立构思。接收任意的入参（即“props”），并返回用于描述页面展示内容的React元素。 函数式组件 123function Demo(props) &#123; return &lt;h1&gt;hello, &#123; props.word &#125;&lt;/h1&gt;&#125; class组件 12345678class Demo extends React.Component&#123; constructor(props) &#123; super(props) &#125; render() &#123; return &lt;h1&gt;hello, &#123; this.props.word &#125;&lt;/h1&gt; &#125;&#125; 以上两个组件在React中效果是相同的 生命周期 挂载 componentDidMount() 更新 shouldComponentUpdate() getSnapshotBeforeUpdate() componentDidUpdate() 卸载 componentWillUnmount() 错误处理 componentDidCatch() 图示： 条件渲染jsx中使用javascipt条件语句判断即可 列表渲染使用javascript的数组方法map遍历即可 1234const numbers = [1, 2, 3, 4, 5]const listItems = numbers.map(number =&gt; &#123; &lt;li key=&#123;number.toString()&#125;&gt;&#123; number &#125;&lt;/li&gt;&#125;) 事件处理将事件名传入到click事件即可，一般为方便使用（this的绑定）直接绑定闭包即可 1&lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;&lt;/button&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"studay","slug":"studay","date":"2020-02-10T07:00:18.000Z","updated":"2020-02-19T10:06:51.194Z","comments":true,"path":"posts/762638ef.html","link":"","permalink":"https://snow-sprite.github.io/posts/762638ef.html","excerpt":"","text":"###流感肆虐，无法上班。然并无工作安排，遂学而时习之，习之并记之，同博客内容匮乏也，丰富之。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"https://snow-sprite.github.io/tags/js/"}],"keywords":[]},{"title":"EveningMommont","slug":"EveningMommont","date":"2020-01-18T13:56:07.000Z","updated":"2020-02-17T10:01:41.954Z","comments":true,"path":"posts/3156ade1.html","link":"","permalink":"https://snow-sprite.github.io/posts/3156ade1.html","excerpt":"","text":"慵懒了一天，快6点了，想起来快过年了，正月不能理头发，赶紧出门理个发吧。看了下日历，距离上次理发过去了1个月又10天。说走就走，出门想起垃圾忘了带了。。。算了，明天上班再扔吧。蹬着我心爱的小山地，10来分钟到达上次理发的地方。停好自行车，抬头看到两个理发店，环顾了一下还是来到了上次理发的这家，68号，不为别的因为人多。跟饭馆吃饭一个道理。年味在这个时候，这种地方应该是最重的地方之一了吧。每年都是过年前这几天最热闹，临近过年上班的心已经抛的远远的了，但是真过年吧也就那么回事了。理发师已经全部上岗了，前面排队的还有大概10来位。我拖了把椅子找了个靠墙的位置坐了下来，没事做那就丰富丰富我的博客吧，如果还叫博客的话–没一会，一个中年妇女带着一个小伙子来理发，小师傅说起码还得等2个小时，犹豫了一会他们就走了。过去一个小时了，陆陆续续还有人进来，我已经有点坐不住了。。。7点半了。。。困死了。。。快8点半了，我是谁我在哪9点半了，终于理完回来了。。话说保定的蛋炒饭卖¥9一份，你是膨胀了吗？？？","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"Hello2020, Bye2019.","slug":"Bye2019, Hello2020","date":"2020-01-01T08:19:09.000Z","updated":"2020-01-18T13:54:41.613Z","comments":true,"path":"posts/2fd14b43.html","link":"","permalink":"https://snow-sprite.github.io/posts/2fd14b43.html","excerpt":"","text":"回顾2019 本来是不想写这篇博客的，不是没时间是没心情，但是看到朋友圈大家都在做年终总结迎接2020，跟个大潮吧。 2019，10年的最后一年，对于我来说没什么可留恋的，所有的坏事情基本都发生在2019。具体什么事情，看客永远都只是看热闹，所以不矫情，略过。 今年年底前俩月做了一个决定，从帝都回到了小3、4线城市-保定，初来乍到对这边行情也不是很了解，所以工资的话可能会处于平均水平了，心理落差还是会有的。来这边工作已经满2个月了，说实话还是有点小小不适应，无论是工作安排还是工作内容又或者是技术栈。习惯了北京的朝10晚9，在这里确实会感觉到一点悠闲，但悠闲带来的是自己的时间更多了，有舍有得嘛。之前的工作虽然忙忙碌碌但是那个忙碌仿佛只是为了尽力完成任务，达到领导口中的kpi，自己并没几见觉到质的飞跃，这一点从之后的找工作写简历体现的淋漓尽致。。 还有一点，有点感慨不管是新同事还是老同事，同事难道真的就只是同事吗？ 说不矫情还是有点矫情了。 来保定俩月时间，还是有收获的。比如自己一个月时间开发了一个凑合能看能用的桌面压缩图片工具。之前没时间搞的时候，对于ui同学动不动给的大几M图片都是找的在线图片压缩工具，但是基本都是一张一张上传或者有限制的多张上传，费时费力。自己开发的这个工具可以批量处理图片了，拖拽一个文件夹等一会就完事了，so easy。 很长时间不写字，自诩文艺青年的我有点才思枯竭了，也不凑字数了，现在是2020年1月1日16:10:51，一会出门骑车溜达会，晚上去感受下第4级孤独😄。 展望20202020年的第一天，对新的一年展望一下顺便立个flag，希望2020都能实现：） 博客地址迁移到https://blog.zhiozhou.top一份 Compress工具自动更新 Compress工具的Chrome扩展程序 把动工了2年还是个雏形的个人网站重构并上线 熟悉flutter，做一个app 组个couple（这个随缘吧😶😄😂，哈哈哈…)","categories":[],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://snow-sprite.github.io/tags/年度总结/"}],"keywords":[]},{"title":"2019年的第二场雪","slug":"Second Snow","date":"2019-12-10T12:05:56.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/c05f9ad0.html","link":"","permalink":"https://snow-sprite.github.io/posts/c05f9ad0.html","excerpt":"","text":"发图上瘾系列 至于第一场雪哪去了， 抱歉..睡懒觉错过.","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"Bad attitude","slug":"Old Time","date":"2019-12-09T12:30:03.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/65cfa396.html","link":"","permalink":"https://snow-sprite.github.io/posts/65cfa396.html","excerpt":"","text":"周末雾霾太大了，没出门。今天周一早上上班出门吓我一跳，这天气腾云驾霾，发一波旧照片找找感觉。 📍北京•\b奥林匹克森林公园📸：2019-06-08📝：2019-12-09","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"2.有效的括号","slug":"2.Valid parentheses","date":"2019-11-27T12:26:54.000Z","updated":"2020-01-01T08:40:38.602Z","comments":true,"path":"posts/308e5841.html","link":"","permalink":"https://snow-sprite.github.io/posts/308e5841.html","excerpt":"","text":"有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例1：12输入: \"()\"输出: true 示例2：12输入: \"()[]&#123;&#125;\"输出: true 示例3：12输入: \"(]\"输出: false 示例4：12输入: \"([)]\"输出: false 示例5：12输入: \"&#123;[]&#125;\"输出: true 思路： 根据栈的知识LIFO，我们可以从左往右遍历如果是左半边括号先把左半边括号（”(“, “[“，”{“）对应的另外一半先存到栈里，遇到右半边括号则比较其与栈中推出的最后一位元素是否相同，如果不同则不是有效字符串，如果相同则依次比较剩下的元素，直到栈为空则为有效字符串，不为空则为无效字符串 实现12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isValid = function(s) &#123; let arr = [] for (let str of s) &#123; if (str === '(') &#123; arr.push(')') &#125; else if (str === '[') &#123; arr.push(']') &#125; else if (str === '&#123;') &#123; arr.push('&#125;') &#125; else if (str !== arr.pop()) &#123; return false &#125; &#125; return !arr.length&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow-sprite.github.io/tags/算法/"}],"keywords":[]},{"title":"再见鼠绘","slug":"Goodbye Shuhui","date":"2019-11-22T16:52:00.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/140ab620.html","link":"","permalink":"https://snow-sprite.github.io/posts/140ab620.html","excerpt":"","text":"再见鼠绘由于最近事比较多，连着两周没怎么追海贼，刚才想看漫画了就去鼠绘看了下还是没更新，咋回事？？？ 看底下评论大家也是一样懵。后来看到有人转发汉化组长最后一条微博，原文： 抱歉，漫停，尚安，勿念。日后有机会给大家交代。帝都屠魔都。 ​​​​ 之前由于网络原因打不开鼠绘时去隔壁企鹅看了一下，讲真企鹅汉化跟鼠绘汉化简直不是一个级别的，又是一个经典的离开，这世界真的没有谁离不开谁，只有谁舍不得离开谁。 再见鼠绘 再见，u","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"1.设计循环队列","slug":"1.Circular queue","date":"2019-11-22T13:38:41.000Z","updated":"2020-01-01T08:40:50.208Z","comments":true,"path":"posts/61605a2e.html","link":"","permalink":"https://snow-sprite.github.io/posts/61605a2e.html","excerpt":"","text":"设计循环队列先简单讲下队列队列就像我们常见的排队一样，先排队的人先离开，后排队的人后离开（排除所有其他干扰因素），插入（insert）操作也被称为入队(enqueue)，新元素始终被添加在队列的末尾，删除(delete)操作也被称为出队(dequeue)，不论正向还是反方向，你只能操作第一个元素 循环队列循环队列是一个线性结构，遵循FIFO（先进先出）原则并且队尾被连接在队首之后形成一个闭合的循环。也被称为“环形缓冲器”。循环队列的好处是可以利用这个队列之前用过的空间，在一个普通队列里，一旦队列满了就不能再往里面插入元素，即使这个队列前面有删除的元素也没法再继续使用，而循环队列则可以高效的利用这部分空间。 设计一个函数至少实现以下效果 MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 思路：我们假设需要一个固定长度的数组，然后设置两个变量分别存储队首和队尾索引，如果队列有空闲，新插入的元素自动插入到当前队尾后直到队列满为止。先考虑队列队首元素、队尾元素、空、满状态，操作插入删除操作时，会更有一点前进的方向. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Initialize your data structure here. Set the size of the queue to be k. * @param &#123;number&#125; k * 初始化构造函数 * 当前队列长度为k * 初始队首和队尾都为-1 * 初始队列为空数组 */var MyCircularQueue = function(k) &#123; this.length = k; this.head = -1; this.tail = -1; this.queue = [];&#125;;/** * Insert an element into the circular queue. Return true if the operation is successful. * @param &#123;number&#125; value * @return &#123;boolean&#125; * 首次插入元素时需要将head设置为0，多次插入时 tail每次加1就行 * 这里不能用数组push操作，因为当数组有空间时，队尾还要循环回来衔接队首 * */MyCircularQueue.prototype.enQueue = function(value) &#123; if (this.isFull()) return false if (this.isEmpty()) &#123; this.head = 0 &#125; this.tail++ this.queue[this.tail] = value return true &#125;;/** * Delete an element from the circular queue. Return true if the operation is successful. * @return &#123;boolean&#125; * 首先删除队首 * 删除操作不能有空的时候，不然返回false * 当删除操作删除到最后一位时，再删除数组将为空，将head及tail、queue恢复至默认状态 */MyCircularQueue.prototype.deQueue = function() &#123; if (this.isEmpty()) return false if (this.head == this.queue.length - 1 &amp;&amp; this.tail == this.queue.length - 1) &#123; this.queue = [] this.head = -1 this.tail = -1 return true &#125; this.queue.shift() this.tail-- return true&#125;;/** * Get the front item from the queue. * @return &#123;number&#125; * 返回队首元素 */MyCircularQueue.prototype.Front = function() &#123; if (this.isEmpty()) return -1 return this.queue[this.head]&#125;;/** * Get the last item from the queue. * @return &#123;number&#125; * 返回队尾元素 */MyCircularQueue.prototype.Rear = function() &#123; if (this.isEmpty()) return -1 return this.queue[this.tail]&#125;;/** * Checks whether the circular queue is empty or not. * @return &#123;boolean&#125; * 当head和tail都为-1时候，队列为空 */MyCircularQueue.prototype.isEmpty = function() &#123; if (this.head == -1 &amp;&amp; this.tail == -1) return true return false&#125;;/** * Checks whether the circular queue is full or not. * @return &#123;boolean&#125; * 1. 当head为0并且tail为当前队列长度-1时，队列是满的 * 2. 当tail小于head时，说明队尾已经循环回来了，当head减tail等于1的时候，正好队尾接上队首 */MyCircularQueue.prototype.isFull = function() &#123; if (this.head == 0 &amp;&amp; this.tail == this.length - 1) return true if (this.tail &lt; this.head &amp;&amp; this.head - this.tail == 1) return true return false&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * var obj = new MyCircularQueue(k) * var param_1 = obj.enQueue(value) * var param_2 = obj.deQueue() * var param_3 = obj.Front() * var param_4 = obj.Rear() * var param_5 = obj.isEmpty() * var param_6 = obj.isFull() */","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow-sprite.github.io/tags/算法/"}],"keywords":[]},{"title":"nvm的安装","slug":"nvm_install","date":"2019-03-04T07:58:55.000Z","updated":"2020-01-01T08:45:33.729Z","comments":true,"path":"posts/b2b0af19.html","link":"","permalink":"https://snow-sprite.github.io/posts/b2b0af19.html","excerpt":"","text":"卸载当前node官网pkg安装包安装的1sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125; homebrew安装的1brew uninstall node tips node卸载完，基于node的软件和命令行工具也需要重新安装，需要删除/usr/local/bin 下面的相关文件，其实他们都是软连接，正主都在/usr/local/lib/node_modules/目录下. 安装nvm安装方式nvm官方文档 安装报错 我在安装过程中可能会报错没有.nvm目录（具体报错信息不记得了 - -!），新建即可12cd ~mkdir .nvm 再次运行安装命令会把安装文件填充到该目录 提示：command not found: nvm复制安装时 提示最底下的三行命令：123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 然后1vim ~/.bash_profile #将复制的文本粘贴进来 如果使用zsh，在.zshrc中也粘进去 如图：如果以上设置仍不生效，尝试：12vim ~/.bash_profilesource .bashrc 使用nvm1234567891011nvm ls ## 查找本电脑上所有的node版本nvm install ## 安装最新版本nvmnvm uninstall &lt;version&gt; ## 卸载制定的版本nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm current ## 显示当前版本nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包nvm on ## 打开nodejs控制nvm off ## 关闭nodejs控制nvm proxy ## 查看设置与代理 好了，愉快的使用nvm来管理node吧 最后，别忘了将之前全局安装的软件重新安装一遍→ →1npm install -g @vue/cli@3.1.3 @vue/cli-init@3.1.1 babel-eslint@9.0.0 bower@1.8.4 chromedriver@2.41.0 create-react-app@1.5.2 eslint@5.10.0 eslint-config-airbnb@17.1.0 eslint-config-react-app@3.0.5 eslint-config-standard@12.0.0 eslint-plugin-flowtype@2.0.1 eslint-plugin-import@2.14.0 eslint-plugin-jsx-a11y@6.1.1 eslint-plugin-node@8.0.0 eslint-plugin-promise@4.0.1 eslint-plugin-react@7.11.1 eslint-plugin-standard@4.0.0 eslint-plugin-vue@5.0.0 express@4.16.4 express-generator@4.16.0 gulp@3.9.1 gulp-cli@2.0.1 hexo-cli@1.1.0 nrm@1.0.2 parcel-bundler@1.9.7 pm2@3.0.4 react-native-cli@2.0.1 sass@1.13.1 typescript@3.1.1 webpack@4.17.2 wepy-cli@1.7.3","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://snow-sprite.github.io/tags/工具/"}],"keywords":[]},{"title":"年后第一篇","slug":"🐭","date":"2019-02-19T09:45:53.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/6d323993.html","link":"","permalink":"https://snow-sprite.github.io/posts/6d323993.html","excerpt":"","text":"","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"Happy New Year","slug":"Happy New Year","date":"2019-01-18T10:33:05.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/2a70ced8.html","link":"","permalink":"https://snow-sprite.github.io/posts/2a70ced8.html","excerpt":"","text":"马上过年了，预祝各位新的一年里芝麻开花，玉兔东升。 ：）","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-10T02:26:22.000Z","updated":"2020-01-01T08:49:55.329Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://snow-sprite.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome!","categories":[],"tags":[{"name":"几见","slug":"几见","permalink":"https://snow-sprite.github.io/tags/几见/"}],"keywords":[]}]}